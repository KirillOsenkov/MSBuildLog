<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>MSBuildStructuredLog Download Stats (Light)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root {
  /* Light theme defaults */
  --bg: #f5f7fa;
  --panel: #ffffff;
  --accent: #0b70d1;
  --accent2: #d27f15;
  --accent3: #7b39ff;
  --grid: #e1e6ed;
  --text: #182028;
  --muted: #647586;
  --danger: #d91e42;
  --font-stack: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;
}

[data-theme="dark"] {
  --bg: #0f1115;
  --panel: #1b1f27;
  --accent: #5fb3ff;
  --accent2: #f7a146;
  --accent3: #9d6bff;
  --grid: #2a313d;
  --text: #e6edf3;
  --muted: #9aa4af;
  --danger: #ff5370;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-stack);
  line-height: 1.4;
  padding: 1rem;
  -webkit-font-smoothing: antialiased;
}

h1 {
  font-size: 1.25rem;
  margin: 0 0 .75rem;
  font-weight: 600;
  letter-spacing: .4px;
}

#controls {
  display: flex;
  flex-wrap: wrap;
  gap: .75rem;
  align-items: flex-start;
  margin-bottom: .75rem;
}

fieldset {
  border: 1px solid var(--grid);
  padding: .6rem .75rem .75rem;
  border-radius: .6rem;
  min-width: 225px;
  background: var(--panel);
  box-shadow: 0 1px 2px rgba(0,0,0,.05);
}

legend {
  padding: 0 .4rem;
  font-weight: 600;
  color: var(--muted);
  font-size: .75rem;
  letter-spacing: .5px;
}

label {
  display: flex;
  align-items: center;
  gap: .45rem;
  font-size: .72rem;
  cursor: pointer;
  user-select: none;
}

input[type=checkbox], input[type=radio] {
  accent-color: var(--accent);
  cursor: pointer;
}

.range-wrap {
  display: flex;
  flex-direction: column;
  gap: .35rem;
  font-size: .68rem;
}

.range-wrap input[type=range] {
  width: 100%;
}

small {
  color: var(--muted);
  font-size: .65rem;
}

#status {
  font-size: .68rem;
  letter-spacing: .4px;
  color: var(--muted);
  display: flex;
  gap: .75rem;
  flex-wrap: wrap;
  align-items: center;
}

#chartWrap {
  position: relative;
  background: var(--panel);
  border: 1px solid var(--grid);
  border-radius: .9rem;
  padding: .6rem .75rem .85rem;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(0,0,0,.06);
}

canvas {
  width: 100%;
  height: 480px;
  display: block;
}

#tooltip {
  position: absolute;
  pointer-events: none;
  background: rgba(255,255,255,.92);
  border: 1px solid var(--grid);
  backdrop-filter: blur(4px);
  border-radius: .45rem;
  padding: .45rem .6rem;
  font-size: .65rem;
  white-space: nowrap;
  color: var(--text);
  transform: translate(-50%, -110%);
  opacity: 0;
  transition: opacity .15s ease;
  z-index: 10;
  box-shadow: 0 4px 10px -2px rgba(0,0,0,.12);
}

#legend {
  margin-top: .35rem;
  display: flex;
  flex-wrap: wrap;
  gap: .55rem .95rem;
  font-size: .65rem;
}

.swatch {
  width: .9rem;
  height: .55rem;
  border-radius: 3px;
  display: inline-block;
  margin-right: .35rem;
  vertical-align: middle;
}

button {
  background: var(--accent);
  color: #ffffff;
  font-weight: 600;
  font-size: .7rem;
  border: none;
  padding: .5rem .9rem;
  border-radius: .55rem;
  cursor: pointer;
  letter-spacing: .5px;
  box-shadow: 0 2px 6px -2px rgba(0,0,0,.25), inset 0 0 0 1px rgba(0,0,0,.08);
  transition: background .15s;
}

button:hover { background: #0c5fb1; }

button.secondary {
  background: var(--panel);
  color: var(--muted);
  box-shadow: inset 0 0 0 1px var(--grid);
}

button.secondary:hover {
  background: #f0f3f7;
}

.theme-toggle {
  background: var(--accent3);
}

.theme-toggle:hover {
  background: #6129d4;
}

a {
  color: var(--accent);
  text-decoration: none;
}
a:hover { text-decoration: underline; }

@media (max-width: 680px) {
  canvas { height: 380px; }
}
</style>
</head>
<body data-theme="light">
<h1>MSBuildStructuredLog Release Download Stats</h1>

<div id="controls">
  <fieldset>
    <legend>File Types</legend>
    <label><input type="checkbox" id="chkReleases" checked> <span>RELEASES file</span></label>
    <label><input type="checkbox" id="chkNupkg" checked> <span>.nupkg assets</span></label>
    <label><input type="checkbox" id="chkCombined"> <span>Combined (merged)</span></label>
  </fieldset>

  <fieldset>
    <legend>Chart Mode</legend>
    <label><input type="radio" name="mode" value="daily" checked> Daily (line)</label>
    <label><input type="radio" name="mode" value="monthly"> Monthly (bar)</label>
  </fieldset>

  <fieldset style="max-width:260px;">
    <legend>Release Limit</legend>
    <div class="range-wrap">
      <label for="releaseLimit">
        <strong>Include first N releases</strong>
      </label>
      <input type="range" id="releaseLimit" min="1" value="1" step="1">
      <div style="display:flex;align-items:center;gap:.5rem;">
        <input type="number" id="releaseLimitNumber" min="1" style="width:80px;padding:.25rem .35rem;font-size:.7rem;">
        <small id="releaseLimitInfo">of ?</small>
      </div>
      <small>
        The limit applies chronologically (earliest → latest). Adjust to focus on early adoption vs. life‑cycle.
      </small>
    </div>
  </fieldset>

  <div style="display:flex;flex-direction:column;gap:.45rem;">
    <button id="btnRefresh" title="Refetch release data">Refresh</button>
    <button id="btnExport" class="secondary" title="Download CSV data">Export CSV</button>
    <button id="btnTheme" class="theme-toggle" title="Toggle Light/Dark">Toggle Theme</button>
  </div>

  <div id="status">Loading…</div>
</div>

<div id="chartWrap">
  <canvas id="chart" width="1280" height="480"></canvas>
  <div id="tooltip"></div>
  <div id="legend"></div>
</div>

<script>
(function(){
  const API_BASE = 'https://api.github.com/repos/KirillOsenkov/MSBuildStructuredLog/releases';
  const PER_PAGE = 100; // GitHub max per_page
  const chart = document.getElementById('chart');
  const ctx = chart.getContext('2d');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const legendEl = document.getElementById('legend');

  const controls = {
    releases: document.getElementById('chkReleases'),
    nupkg: document.getElementById('chkNupkg'),
    combined: document.getElementById('chkCombined'),
    modeDaily: () => document.querySelector('input[name=mode][value=daily]').checked,
    limitRange: document.getElementById('releaseLimit'),
    limitNumber: document.getElementById('releaseLimitNumber'),
    limitInfo: document.getElementById('releaseLimitInfo')
  };

  const btnRefresh = document.getElementById('btnRefresh');
  const btnExport = document.getElementById('btnExport');
  const btnTheme = document.getElementById('btnTheme');

  const COLORS = {
    releases: css('--accent'),
    nupkg: css('--accent2'),
    combined: css('--accent3')
  };

  let allReleases = [];
  let rawAssets = null;
  let seriesDaily = {};
  let seriesMonthly = {};
  let drawnDataPoints = [];
  let maxReleases = 0;

  function css(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

  function fmtDate(d){ return d.toISOString().slice(0,10); }
  function fmtMonth(d){ return d.getUTCFullYear() + '-' + String(d.getUTCMonth()+1).padStart(2,'0'); }
  function daysBetween(a,b){ return Math.max(1, Math.round((b - a) / 86400000)); }
  function setStatus(msg){ statusEl.textContent = msg; }

  async function fetchAllReleases(){
    setStatus('Fetching paginated releases…');
    let page = 1;
    const releases = [];
    while(true){
      const url = API_BASE + '?per_page=' + PER_PAGE + '&page=' + page;
      const res = await fetch(url, { headers: { 'Accept':'application/vnd.github+json' }});
      if(!res.ok){
        throw new Error('GitHub API error ' + res.status);
      }
      const batch = await res.json();
      if(batch.length === 0) break;
      releases.push(...batch.filter(r=>r.published_at));
      setStatus(`Fetched page ${page}, cumulative releases: ${releases.length}`);
      if(batch.length < PER_PAGE) break; // Last page
      page++;
      // Safety: avoid huge loops
      if(page > 50){
        console.warn('Stopped after 50 pages for safety.');
        break;
      }
    }
    return releases.sort((a,b)=> new Date(a.published_at) - new Date(b.published_at));
  }

  function applyLimit(releases){
    // Limit = earliest N releases (chronological subset)
    const limit = Number(controls.limitNumber.value);
    return releases.slice(0, limit);
  }

  function extractAssets(releases){
    const byType = { releases: [], nupkg: [] };
    for(const rel of releases){
      const published = new Date(rel.published_at);
      for(const asset of (rel.assets || [])){
        if(asset.name === 'RELEASES'){
          byType.releases.push({ name: asset.name, published, downloads: asset.download_count, releaseTag: rel.tag_name });
        } else if(asset.name.endsWith('.nupkg')){
          byType.nupkg.push({ name: asset.name, published, downloads: asset.download_count, releaseTag: rel.tag_name });
        }
      }
    }
    return byType;
  }

  function buildDaily(byType){
    const today = new Date();
    const daily = {};

    for(const key of Object.keys(byType)){
      const arr = byType[key];
      const points = [];
      for(let i=0;i<arr.length;i++){
        const cur = arr[i];
        const next = arr[i+1] ? arr[i+1].published : today;
        // Normalize to midnight UTC
        const start = new Date(Date.UTC(cur.published.getUTCFullYear(), cur.published.getUTCMonth(), cur.published.getUTCDate()));
        const end = new Date(Date.UTC(next.getUTCFullYear(), next.getUTCMonth(), next.getUTCDate()));
        const days = daysBetween(start,end);
        const avg = cur.downloads / days;
        for(let d=0; d<days; d++){
          const dayDate = new Date(start.getTime() + d*86400000);
          points.push({ date: dayDate, value: avg, source: key });
        }
      }
      daily[key] = points;
    }
    // Combined
    const combinedMap = new Map();
    for(const key of ['releases','nupkg']){
      daily[key].forEach(pt=>{
        const k = fmtDate(pt.date);
        combinedMap.set(k, (combinedMap.get(k) || 0) + pt.value);
      });
    }
    daily.combined = Array.from(combinedMap.entries()).map(([d,v])=>({
      date: new Date(d+'T00:00:00Z'), value: v, source: 'combined'
    }));
    return daily;
  }

  function buildMonthly(daily){
    const monthly = {};
    for(const key of Object.keys(daily)){
      const map = new Map();
      for(const pt of daily[key]){
        const m = fmtMonth(pt.date);
        map.set(m, (map.get(m) || 0) + pt.value);
      }
      monthly[key] = Array.from(map.entries()).map(([m,v])=>{
        const [year, month] = m.split('-').map(Number);
        return { date: new Date(Date.UTC(year, month-1, 1)), value: v, source: key, label: m };
      }).sort((a,b)=> a.date - b.date);
    }
    return monthly;
  }

  function activeKeys(){
    const keys = [];
    if(controls.releases.checked) keys.push('releases');
    if(controls.nupkg.checked) keys.push('nupkg');
    if(controls.combined.checked) keys.push('combined');
    return keys;
  }

  function makeLegend(keys){
    legendEl.innerHTML = '';
    if(keys.length === 0){
      legendEl.textContent = 'No datasets selected.';
      return;
    }
    keys.forEach(k=>{
      const div = document.createElement('div');
      div.innerHTML = `<span class="swatch" style="background:${COLORS[k]}"></span>${k}`;
      legendEl.appendChild(div);
    });
  }

  function getDisplaySeries(){
    const keys = activeKeys();
    makeLegend(keys);
    return controls.modeDaily() ? keys.map(k=>seriesDaily[k]) : keys.map(k=>seriesMonthly[k]);
  }

  function draw(){
    const w = chart.width = chart.clientWidth * window.devicePixelRatio;
    const h = chart.height = chart.clientHeight * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    ctx.clearRect(0,0,chart.clientWidth, chart.clientHeight);
    ctx.font = '11px ' + css('--font-stack');
    ctx.lineWidth = 1;

    const margin = { left: 60, right: 20, top: 24, bottom: 56 };
    const innerW = chart.clientWidth - margin.left - margin.right;
    const innerH = chart.clientHeight - margin.top - margin.bottom;

    const seriesArr = getDisplaySeries();
    if(seriesArr.every(arr=>!arr || arr.length===0)){
      ctx.fillStyle = css('--muted');
      ctx.fillText('No data to display.', margin.left + 10, margin.top + 20);
      drawnDataPoints = [];
      return;
    }

    const allPts = seriesArr.flat();
    const minDate = Math.min(...allPts.map(p=>p.date.getTime()));
    const maxDate = Math.max(...allPts.map(p=>p.date.getTime()));
    const maxValue = Math.max(...allPts.map(p=>p.value));

    const xScale = (t)=> margin.left + ((t - minDate) / (maxDate - minDate || 1)) * innerW;
    const yScale = (v)=> margin.top + innerH - (v / (maxValue || 1)) * innerH;

    // Grid
    ctx.strokeStyle = css('--grid');
    ctx.lineWidth = 1;
    ctx.beginPath();
    const gridLines = 6;
    for(let i=0;i<=gridLines;i++){
      const y = margin.top + (innerH/gridLines)*i;
      ctx.moveTo(margin.left, y);
      ctx.lineTo(chart.clientWidth - margin.right, y);
    }
    ctx.stroke();

    // Y labels
    ctx.fillStyle = css('--muted');
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for(let i=0;i<=gridLines;i++){
      const v = (maxValue / gridLines) * (gridLines - i);
      const y = margin.top + (innerH/gridLines)*i;
      ctx.fillText(formatNumber(v), margin.left - 8, y);
    }

    // X labels
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const mode = controls.modeDaily() ? 'daily' : 'monthly';
    let ticks = 8;
    if(mode === 'monthly'){
      ticks = Math.min(12, seriesArr[0]?.length || 12);
    }
    for(let i=0;i<=ticks;i++){
      const t = minDate + ((maxDate - minDate) / ticks) * i;
      const xd = xScale(t);
      ctx.fillStyle = css('--muted');
      const d = new Date(t);
      const label = mode === 'daily'
        ? d.toISOString().slice(0,10)
        : fmtMonth(d);
      ctx.save();
      // Slight rotate for space (optional)
      ctx.translate(xd, chart.clientHeight - margin.bottom + 26);
      ctx.rotate(-0.6);
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }

    drawnDataPoints = [];
    if(mode === 'monthly'){
      // Bars (stacked if multiple)
      const keys = activeKeys();
      const grouped = {};
      keys.forEach(k=>{
        seriesMonthly[k].forEach(pt=>{
          const id = fmtMonth(pt.date);
          if(!grouped[id]) grouped[id] = [];
          grouped[id].push(pt);
        });
      });
      const months = Object.keys(grouped).sort();
      const barBand = innerW / months.length;
      const barWidth = barBand * 0.6;

      months.forEach((m, mi)=>{
        const pts = grouped[m];
        const baseX = margin.left + barBand * mi + barBand/2;
        let stackAccum = 0;
        pts.forEach(p=>{
          const height = (p.value / maxValue) * innerH;
          const x = baseX - barWidth/2;
            const y = yScale(stackAccum + p.value);
          ctx.fillStyle = COLORS[p.source] + 'd9';
          roundedRect(ctx, x, y, barWidth, height, 4);
          ctx.fill();
          drawnDataPoints.push({ x, y, w: barWidth, h: height, value: p.value, date: p.label, source: p.source });
          stackAccum += p.value;
        });
      });
    } else {
      // Lines
      const keys = activeKeys();
      keys.forEach(k=>{
        const pts = seriesDaily[k];
        if(!pts || pts.length===0) return;
        ctx.lineWidth = 2;
        ctx.strokeStyle = COLORS[k];
        ctx.beginPath();
        pts.forEach((p,i)=>{
          const x = xScale(p.date.getTime());
          const y = yScale(p.value);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          drawnDataPoints.push({ x, y, r: 4, value: p.value, date: fmtDate(p.date), source: k });
        });
        ctx.stroke();

        if(pts.length <= 400){
          ctx.fillStyle = COLORS[k];
          pts.forEach(p=>{
            const x = xScale(p.date.getTime());
            const y = yScale(p.value);
            ctx.beginPath();
            ctx.arc(x,y,3,0,Math.PI*2);
            ctx.fill();
          });
        }
      });
    }

    // Axes
    ctx.strokeStyle = css('--muted');
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + innerH);
    ctx.lineTo(chart.clientWidth - margin.right, margin.top + innerH);
    ctx.stroke();

    ctx.fillStyle = css('--muted');
    ctx.font = '12px ' + css('--font-stack');
    ctx.textAlign = 'center';
    ctx.fillText(
      mode === 'daily'
        ? 'Daily Average Downloads'
        : 'Monthly Downloads (sum of daily averages in period)',
      chart.clientWidth/2, 8
    );
  }

  function roundedRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  function formatNumber(n){
    if(n >= 1_000_000) return (n/1_000_000).toFixed(1)+'M';
    if(n >= 1_000) return (n/1_000).toFixed(1)+'K';
    return n.toFixed(0);
  }

  function rebuild(){
    if(!allReleases.length) return;
    const limited = applyLimit(allReleases);
    rawAssets = extractAssets(limited);
    seriesDaily = buildDaily(rawAssets);
    seriesMonthly = buildMonthly(seriesDaily);
    setStatus(
      `Total releases: ${maxReleases} | Showing: ${limited.length} | RELEASES assets: ${rawAssets.releases.length} | .nupkg assets: ${rawAssets.nupkg.length}`
    );
    draw();
  }

  async function init(force=false){
    try{
      if(force || allReleases.length === 0){
        setStatus('Loading releases…');
        allReleases = await fetchAllReleases();
        maxReleases = allReleases.length;
        // Initialize limit controls
        controls.limitRange.max = maxReleases;
        controls.limitNumber.max = maxReleases;
        controls.limitRange.value = maxReleases;
        controls.limitNumber.value = maxReleases;
        controls.limitInfo.textContent = `of ${maxReleases}`;
      }
      rebuild();
    }catch(err){
      console.error(err);
      setStatus('Error: ' + err.message);
    }
  }

  // Tooltip
  chart.addEventListener('mousemove', e=>{
    const rect = chart.getBoundingClientRect();
    const x = (e.clientX - rect.left) * window.devicePixelRatio;
    const y = (e.clientY - rect.top) * window.devicePixelRatio;
    const mode = controls.modeDaily() ? 'daily' : 'monthly';
    let hit = null;

    if(mode === 'monthly'){
      for(const dp of drawnDataPoints){
        if(x >= dp.x && x <= dp.x + dp.w && y >= dp.y && y <= dp.y + dp.h){
          hit = dp; break;
        }
      }
    } else {
      let minDist = Infinity;
      for(const dp of drawnDataPoints){
        const dx = x - dp.x;
        const dy = y - dp.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist < 16 && dist < minDist){
          hit = dp;
          minDist = dist;
        }
      }
    }

    if(hit){
      tooltip.style.opacity = 1;
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = (e.clientY - 10) + 'px';
      tooltip.innerHTML =
        `<strong>${hit.source}</strong><br>${hit.date}<br>${hit.value.toFixed(2)} downloads`;
    } else {
      tooltip.style.opacity = 0;
    }
  });

  chart.addEventListener('mouseleave', ()=> tooltip.style.opacity = 0);

  // Export CSV
  btnExport.addEventListener('click', ()=>{
    if(!seriesDaily.releases) return;
    const rows = [];
    rows.push(['date','releases_daily','nupkg_daily','combined_daily','month','releases_month','nupkg_month','combined_month']);
    const dailyMap = new Map();
    ['releases','nupkg','combined'].forEach(k=>{
      seriesDaily[k].forEach(p=>{
        const key = fmtDate(p.date);
        if(!dailyMap.has(key)) dailyMap.set(key, { date: key });
        dailyMap.get(key)[k] = p.value;
      });
    });
    const monthMap = new Map();
    ['releases','nupkg','combined'].forEach(k=>{
      seriesMonthly[k].forEach(p=>{
        const key = fmtMonth(p.date);
        if(!monthMap.has(key)) monthMap.set(key, { month: key });
        monthMap.get(key)[k] = p.value;
      });
    });

    const allDates = Array.from(dailyMap.keys()).sort();
    allDates.forEach(d=>{
      const dailyRow = dailyMap.get(d);
      const m = d.slice(0,7);
      const monthRow = monthMap.get(m) || {};
      rows.push([
        d,
        dailyRow.releases ?? '',
        dailyRow.nupkg ?? '',
        dailyRow.combined ?? '',
        m,
        monthRow.releases ?? '',
        monthRow.nupkg ?? '',
        monthRow.combined ?? ''
      ]);
    });

    // Any months without daily rows
    const months = Array.from(monthMap.keys()).sort();
    months.forEach(m=>{
      if(!allDates.some(d=>d.startsWith(m))){
        const mr = monthMap.get(m);
        rows.push(['','','','', m, mr.releases ?? '', mr.nupkg ?? '', mr.combined ?? '']);
      }
    });

    const csv = rows.map(r=>r.map(cell=>String(cell).replace(/"/g,'""')).map(c=> `"${c}"`).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'download-stats.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // Theme toggle
  btnTheme.addEventListener('click', ()=>{
    const body = document.body;
    const cur = body.getAttribute('data-theme');
    body.setAttribute('data-theme', cur === 'dark' ? 'light' : 'dark');
    draw();
  });

  // Limit events
  function syncLimitFromRange(){
    controls.limitNumber.value = controls.limitRange.value;
    rebuild();
  }
  function syncLimitFromNumber(){
    let val = Number(controls.limitNumber.value);
    if(val < 1) val = 1;
    if(val > maxReleases) val = maxReleases;
    controls.limitNumber.value = val;
    controls.limitRange.value = val;
    rebuild();
  }
  controls.limitRange.addEventListener('input', syncLimitFromRange);
  controls.limitNumber.addEventListener('change', syncLimitFromNumber);

  // Other control events
  [controls.releases, controls.nupkg, controls.combined].forEach(el=> el.addEventListener('change', draw));
  document.querySelectorAll('input[name=mode]').forEach(r=> r.addEventListener('change', draw));
  btnRefresh.addEventListener('click', ()=> init(true));
  window.addEventListener('resize', ()=> draw(), { passive: true });

  init();
})();
</script>
</body>
</html>